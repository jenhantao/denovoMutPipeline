#! /usr/bin/env python

import sys
import itertools
from optparse import OptionParser

"""
Note: In the future may want to have config file as an input as well.
      Can have more generic variables such as 'aligner'
      This will enable customization as long as file formats generated by tools are valid
"""

class CmdOpts(object):
   usage="""%prog [options] -f meta file -d datadir -p project name

   Generate a file with commands to run the pipeline on a set of exomes
   
   -f Meta file with data uri and sample information for each bam file
   -d Data directory (~/mnt, ./data, ...)
   -p The project directory in the gtfuse mount directory where bam files for this project will be mounted
   -t Whether jobs should be run serially (VM) or in parallel (cluster). Since the Annai VM has limited storage, need to run
      samples one at a time and remove intermediate files between samples.
   #Fixme - implement a way to constrain analyses? Either NT or NB. Include, exclude metastasis?
   -c comma separated list of tissue codes to run (e.g. 01,10 for solid tumor, blood normal)

   Example:
      tasks/callPipe -f data/BRCA_TRN/meta.txt -d /home/moores/mnt -p BRCA_TRN > BRCA_TRN.run


   Notes:
   The file with meta information for the set of bam files to process is generated
   by the script 'getDataUri.sh'

   
   """
   def __init__(self):
      parser = OptionParser(usage=CmdOpts.usage)
      parser.add_option("-f", "--file", dest="filename",
                        help="""Meta file for set of exomes to process""")
      parser.add_option("-d", "--dataloc", dest="dataloc",
                        default="/home/moores/mnt", help="""Directory where gtdownload directories / gtfuse mounts are created""")
      parser.add_option("-p", "--project", dest="projectdir",
                        help="""Name of project. Should correspond to directory name on gtfuse mount where project bam files are mounted""")
      parser.add_option("-t", "--runtype", dest="type",
                        default="VM", help="""Type of run - VM (serial) versus cluster (parallel)""")
      (opts, args) = parser.parse_args()

      if not opts.filename or not opts.projectdir:
         parser.error("Incorrect input args")
      
      if opts.dataloc.endswith("/"):
         opts.dataloc = opts.dataloc[:-1]

      self.__dict__.update(opts.__dict__)


class MetaReader(object):
   """
   Read meta data generated with cgquery
   """
   def __init__(self, filename, dataloc, projectdir):
      self.fh = file(filename,'r')
      self.dataloc = dataloc
      self.projectdir = projectdir
      
   def __iter__(self):
         return self

   def next(self):
      while True:
         line = self.fh.readline()
         if line == "":
            self.fh.close()
            raise StopIteration
         line = line[:-1]
         return BamInfo(line.split("\t"), self.dataloc, self.projectdir)
         

class BamInfo(object):

   """
   Notes:      
   01  Primary solid Tumor  TP
   02  Recurrent Solid Tumor  TR
   03  Primary Blood Derived Cancer - Peripheral Blood  TB
   04  Recurrent Blood Derived Cancer - Bone Marrow  TRBM
   05  Additional - New Primary  TAP
   06  Metastatic  TM
   07  Additional Metastatic  TAM
   08  Human Tumor Original Cells  THOC
   09  Primary Blood Derived Cancer - Bone Marrow  TBM
   10  Blood Derived Normal  NB
   11  Solid Tissue Normal  NT
   12  Buccal Cell Normal  NBC
   13  EBV Immortalized Normal  NEBV
   14  Bone Marrow Normal  NBM
   20  Control Analyte  CELLC
   40  Recurrent Blood Derived Cancer - Peripheral Blood  TRB
   50  Cell Lines  CELL
   60  Primary Xenograft Tissue  XP
   61  Cell Line Derived Xenograft Tissue   XCL 
   """

   tissue_dict = {"01":"TP","02":"TR","03":"TB","04":"TRBM","05":"TAP","06":"TM","07":"TAM","08":"THOC","09":"TBM","10":"NB","11":"NT","12":"NBC","13":"EBV","14":"NBM","20":"CELLC","40":"TRB","50":"CELL","60":"XP","61":"XCL"}
   sample_dict = {"01":"Tumor","02":"Tumor","03":"Tumor","04":"Tumor","05":"Tumor","06":"Tumor","07":"Tumor","08":"Tumor","09":"Tumor","10":"Normal","11":"Normal","12":"Normal","13":"Normal","14":"Normal","20":"CELLC","40":"Tumor","50":"CELL","60":"Tumor","61":"Tumor"}
   
   def __init__(self, row, dataloc, projectdir):
      self.sample = row[0]
      self.sampletype = row[1]
      self.bamuri = row[2]
      self.platform = row[3]
      self.library = row[4]
      self.projectdir = projectdir
      self.shortname = "-".join(self.sample.split("-")[:3])
      self.stype = BamInfo.tissue_dict.get(self.sampletype)
      self.bampath = dataloc + "/" + projectdir + "/" + self.bamuri.split("/")[-1] 
      self.bamtype = BamInfo.sample_dict.get(self.sampletype)

   def __repr__(self):
      #return " ".join(["bash","./pipe_single.sh", self.bampath, self.projectdir, self.shortname, self.stype, self.platform, self.library])
      return " ".join(["bash","./pipe_single.sh", self.bampath, self.projectdir, self.shortname, self.stype])


class BamTbl(object):
   """
   Store information about bam files to process
   """
   
   def __init__(self, filename, dataloc, projectdir): ##, codes):
      self.bamlist = []
      self.samplelist = []
      self.bamBySample = {}
      self.projectdir = projectdir
      for bam in MetaReader(filename, dataloc, projectdir):
         self.__addBam(bam)

   def __addBam(self, bam):
      self.bamlist.append(bam)
      if bam.shortname not in self.samplelist:
         self.samplelist.append(bam.shortname)
      if self.bamBySample.has_key(bam.shortname):
         self.bamBySample[bam.shortname].append(bam)
      else:
         self.bamBySample[bam.shortname] = [bam]
   
   def buildRunCommandsVM(self):
      """
      Prepare jobs to run serially on a VM
      """
      for sample in self.samplelist:
         bams = self.bamBySample.get(sample)
         for bam in bams:
            print bam
         grp = BamGroup(sample, self.projectdir, bams)   
         print grp
         print grp.printgermline()
         print grp.printpairs()
         print " ".join(["tasks/removeIntermediates.sh", self.projectdir, sample])

   def buildCommandsCluster(self):
      """
      Prepare jobs to run in parallel across the nodes of a cluster
      """
      for bam in self.bamlist:
         print bam
      for sample in self.samplelist:
         print BamGroup(sample, self.projectdir)
         

class BamGroup(object):
   
   def __init__(self, samplename, projectdir, bams):
      self.samplename = samplename
      self.projectdir = projectdir
      self.__getPairs(bams)

   def __getPairs(self, bams):
      """
      Determine all pairwise combinations for which to call somatic variants
      """
      self.pairs = []
      normal = [x.stype for x in bams if x.bamtype == "Normal"]
      tumor = [x.stype for x in bams if x.bamtype == "Tumor"]
      self.normals = normal
      self.tumors = tumor
      for pair in itertools.product(normal, tumor):
         self.pairs.append(pair)
   
   def printpairs(self):
      return "\n".join([" ".join(["bash","./pipe_mutect.sh",self.projectdir,self.samplename,x[0],x[1]]) for x in self.pairs])

   def printgermline(self):
      if "TP" in self.tumors:   
         normal = "NB" if "NB" in self.normals else self.normals[0]
      elif "TB" in self.tumors:
         normal = "NT" if "NT" in self.normals else self.normals[0]
      return " ".join(["bash","./pipe_germline.sh",self.projectdir, self.samplename, normal]) 
               
   def __repr__(self):
      return " ".join(["bash","./pipe_grouped.sh",self.projectdir, self.samplename])


def main():
   
   opts = CmdOpts()

   bamtbl = BamTbl(opts.filename, opts.dataloc, opts.projectdir)
   
   if opts.type == "VM":
      bamtbl.buildRunCommandsVM()
   elif opts.type == "cluster":
      bamtbl.buildRunCommandsCluster()

if __name__ == "__main__":
   main()
